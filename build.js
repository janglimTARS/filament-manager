const fs = require('fs');
const path = require('path');

const htmlContent = fs.readFileSync(path.join(__dirname, 'public', 'index.html'), 'utf8');
const jsContent = fs.readFileSync(path.join(__dirname, 'public', 'app.js'), 'utf8');
const cssContent = fs.readFileSync(path.join(__dirname, 'public', 'styles.css'), 'utf8');

const workerContent = `// This file is auto-generated by build.js
const HTML_CONTENT = ${JSON.stringify(htmlContent)};
const JS_CONTENT = ${JSON.stringify(jsContent)};
const CSS_CONTENT = ${JSON.stringify(cssContent)};

function json(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: { 'Content-Type': 'application/json;charset=UTF-8' },
  });
}

async function readBody(request) {
  try { return await request.json(); }
  catch { return null; }
}

function toSpoolRow(input) {
  return {
    id: String(input.id || crypto.randomUUID()),
    brand: String(input.brand || '').trim(),
    color_name: String(input.colorName || input.color_name || '').trim(),
    color_hex: String(input.colorHex || input.color_hex || '#ffffff').trim() || '#ffffff',
    material: String(input.material || 'PLA').trim() || 'PLA',
    diameter: Number(input.diameter) || 1.75,
    total_weight: Number(input.totalWeight ?? input.total_weight),
    remaining_weight: Number(input.remainingWeight ?? input.remaining_weight),
    location: String(input.location || '').trim(),
    purchase_date: String(input.purchaseDate || input.purchase_date || '').trim(),
    cost: Number(input.cost) || 0,
    notes: String(input.notes || '').trim(),
  };
}

function spoolToApi(row) {
  return {
    id: row.id,
    brand: row.brand,
    colorName: row.color_name,
    colorHex: row.color_hex,
    material: row.material,
    diameter: Number(row.diameter),
    totalWeight: Number(row.total_weight),
    remainingWeight: Number(row.remaining_weight),
    location: row.location || '',
    purchaseDate: row.purchase_date || '',
    cost: Number(row.cost || 0),
    notes: row.notes || '',
    createdAt: row.created_at,
    updatedAt: row.updated_at,
  };
}

function printEventToApi(row) {
  return {
    id: row.id,
    fileName: row.file_name || '',
    activeTray: Number(row.active_tray ?? -1),
    spoolId: row.spool_id || '',
    filamentUsedG: Number(row.filament_used_g || 0),
    status: row.status || 'pending',
    completedAt: row.completed_at || '',
    resolvedAt: row.resolved_at || '',
  };
}

async function handleApi(request, env, url) {
  const { pathname } = url;
  const method = request.method.toUpperCase();

  if (pathname === '/api/spools' && method === 'GET') {
    const rows = await env.DB.prepare('SELECT * FROM spools ORDER BY datetime(created_at) DESC').all();
    return json((rows.results || []).map(spoolToApi));
  }

  if (pathname === '/api/spools' && method === 'POST') {
    const body = await readBody(request);
    if (!body) return json({ error: 'Invalid JSON body' }, 400);

    const spool = toSpoolRow(body);
    if (!spool.brand || !spool.color_name || Number.isNaN(spool.total_weight) || Number.isNaN(spool.remaining_weight)) {
      return json({ error: 'Missing required spool fields' }, 400);
    }
    if (spool.remaining_weight > spool.total_weight) {
      return json({ error: 'Remaining weight cannot be greater than total weight' }, 400);
    }

    await env.DB.prepare(
      'INSERT INTO spools (id, brand, color_name, color_hex, material, diameter, total_weight, remaining_weight, location, purchase_date, cost, notes) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
    ).bind(
      spool.id, spool.brand, spool.color_name, spool.color_hex, spool.material, spool.diameter,
      spool.total_weight, spool.remaining_weight, spool.location, spool.purchase_date, spool.cost, spool.notes
    ).run();

    return json({ ok: true, id: spool.id }, 201);
  }

  const spoolMatch = pathname.match(new RegExp('^/api/spools/([^/]+)$'));
  if (spoolMatch && method === 'PUT') {
    const id = decodeURIComponent(spoolMatch[1]);
    const body = await readBody(request);
    if (!body) return json({ error: 'Invalid JSON body' }, 400);

    const spool = toSpoolRow({ ...body, id });
    if (!spool.brand || !spool.color_name || Number.isNaN(spool.total_weight) || Number.isNaN(spool.remaining_weight)) {
      return json({ error: 'Missing required spool fields' }, 400);
    }
    if (spool.remaining_weight > spool.total_weight) {
      return json({ error: 'Remaining weight cannot be greater than total weight' }, 400);
    }

    const result = await env.DB.prepare(
      "UPDATE spools SET brand=?, color_name=?, color_hex=?, material=?, diameter=?, total_weight=?, remaining_weight=?, location=?, purchase_date=?, cost=?, notes=?, updated_at=datetime('now') WHERE id=?"
    ).bind(
      spool.brand, spool.color_name, spool.color_hex, spool.material, spool.diameter,
      spool.total_weight, spool.remaining_weight, spool.location, spool.purchase_date, spool.cost, spool.notes, id
    ).run();

    if (!result.success) return json({ error: 'Failed to update spool' }, 500);
    return json({ ok: true });
  }

  if (spoolMatch && method === 'DELETE') {
    const id = decodeURIComponent(spoolMatch[1]);
    await env.DB.prepare('DELETE FROM spools WHERE id = ?').bind(id).run();
    return json({ ok: true });
  }

  if (pathname === '/api/ams-mapping' && method === 'GET') {
    const rows = await env.DB.prepare('SELECT slot, spool_id FROM ams_spool_mapping ORDER BY slot ASC').all();
    return json((rows.results || []).map((r) => ({
      slot: Number(r.slot),
      spoolId: String(r.spool_id || ''),
    })));
  }

  const amsMappingMatch = pathname.match(new RegExp('^/api/ams-mapping/(\\\\d+)$'));
  if (amsMappingMatch && method === 'PUT') {
    const slot = Number(amsMappingMatch[1]);
    const body = await readBody(request);
    if (!body || typeof body.spoolId !== 'string') return json({ error: 'spoolId is required' }, 400);

    await env.DB.prepare(
      "INSERT INTO ams_spool_mapping (slot, spool_id, updated_at) VALUES (?, ?, datetime('now')) ON CONFLICT(slot) DO UPDATE SET spool_id=excluded.spool_id, updated_at=datetime('now')"
    ).bind(slot, body.spoolId.trim()).run();

    return json({ ok: true });
  }

  if (amsMappingMatch && method === 'DELETE') {
    const slot = Number(amsMappingMatch[1]);
    await env.DB.prepare(
      "INSERT INTO ams_spool_mapping (slot, spool_id, updated_at) VALUES (?, '', datetime('now')) ON CONFLICT(slot) DO UPDATE SET spool_id='', updated_at=datetime('now')"
    ).bind(slot).run();
    return json({ ok: true });
  }

  if (pathname === '/api/print-completed' && method === 'POST') {
    const body = await readBody(request);
    if (!body) return json({ error: 'Invalid JSON body' }, 400);

    const fileName = String(body.fileName || body.file_name || '').trim();
    const activeTray = Number(body.activeTray ?? body.active_tray ?? -1);
    const completedAt = String(body.completedAt || body.completed_at || new Date().toISOString());
    const id = crypto.randomUUID();

    const mapping = Number.isFinite(activeTray)
      ? await env.DB.prepare('SELECT spool_id FROM ams_spool_mapping WHERE slot = ? LIMIT 1').bind(activeTray).first()
      : null;
    const spoolId = String(mapping?.spool_id || '').trim();

    await env.DB.prepare(
      'INSERT INTO print_events (id, file_name, active_tray, spool_id, filament_used_g, status, completed_at, resolved_at) VALUES (?, ?, ?, ?, 0, ?, ?, ?)' 
    ).bind(
      id,
      fileName,
      Number.isFinite(activeTray) ? activeTray : -1,
      spoolId,
      'pending',
      completedAt,
      ''
    ).run();

    const row = await env.DB.prepare('SELECT * FROM print_events WHERE id = ? LIMIT 1').bind(id).first();
    return json(printEventToApi(row), 201);
  }

  if (pathname === '/api/print-events' && method === 'GET') {
    const statusFilter = String(url.searchParams.get('status') || '').trim();
    let query = 'SELECT * FROM print_events';
    const binds = [];
    if (statusFilter) {
      query += ' WHERE status = ?';
      binds.push(statusFilter);
    }
    query += ' ORDER BY datetime(completed_at) DESC';

    const rows = await env.DB.prepare(query).bind(...binds).all();
    const events = (rows.results || []).map((row) => printEventToApi(row));

    if (!events.length) return json([]);

    const spoolIds = [...new Set(events.map((e) => e.spoolId).filter(Boolean))];
    const spoolMap = {};
    if (spoolIds.length) {
      const placeholders = spoolIds.map(() => '?').join(', ');
      const spoolRows = await env.DB.prepare(
        'SELECT id, brand, color_name FROM spools WHERE id IN (' + placeholders + ')'
      ).bind(...spoolIds).all();
      for (const row of (spoolRows.results || [])) {
        spoolMap[row.id] = {
          id: row.id,
          brand: row.brand || '',
          colorName: row.color_name || '',
        };
      }
    }

    return json(events.map((event) => ({
      ...event,
      spool: event.spoolId ? (spoolMap[event.spoolId] || null) : null,
    })));
  }

  const printEventMatch = pathname.match(new RegExp('^/api/print-events/([^/]+)$'));
  if (printEventMatch && method === 'PUT') {
    const id = decodeURIComponent(printEventMatch[1]);
    const body = await readBody(request);
    if (!body) return json({ error: 'Invalid JSON body' }, 400);

    const existing = await env.DB.prepare('SELECT * FROM print_events WHERE id = ? LIMIT 1').bind(id).first();
    if (!existing) return json({ error: 'Print event not found' }, 404);

    const nextStatus = String(body.status || 'resolved').trim() || 'resolved';
    const filamentUsedG = Math.max(0, Number(body.filament_used_g ?? body.filamentUsedG ?? 0) || 0);
    const shouldDeduct = nextStatus === 'resolved' && filamentUsedG > 0 && String(existing.spool_id || '').trim();

    if (shouldDeduct) {
      await env.DB.prepare(
        "UPDATE spools SET remaining_weight = MAX(0, remaining_weight - ?), updated_at=datetime('now') WHERE id = ?"
      ).bind(filamentUsedG, existing.spool_id).run();
    }

    await env.DB.prepare(
      "UPDATE print_events SET filament_used_g = ?, status = ?, resolved_at = datetime('now') WHERE id = ?"
    ).bind(filamentUsedG, nextStatus, id).run();

    const updated = await env.DB.prepare('SELECT * FROM print_events WHERE id = ? LIMIT 1').bind(id).first();
    return json(printEventToApi(updated));
  }

  if (pathname === '/api/locations' && method === 'GET') {
    const rows = await env.DB.prepare('SELECT * FROM storage_locations ORDER BY name COLLATE NOCASE ASC').all();
    return json((rows.results || []).map((r) => ({ id: r.id, name: r.name, createdAt: r.created_at })));
  }

  if (pathname === '/api/locations' && method === 'POST') {
    const body = await readBody(request);
    const name = String(body?.name || '').trim();
    if (!name) return json({ error: 'Location name is required' }, 400);
    const id = crypto.randomUUID();

    try {
      await env.DB.prepare('INSERT INTO storage_locations (id, name) VALUES (?, ?)').bind(id, name).run();
      return json({ id, name }, 201);
    } catch (err) {
      return json({ error: 'Location already exists' }, 409);
    }
  }

  const locMatch = pathname.match(new RegExp('^/api/locations/([^/]+)$'));
  if (locMatch && method === 'DELETE') {
    const id = decodeURIComponent(locMatch[1]);
    await env.DB.prepare('DELETE FROM storage_locations WHERE id = ?').bind(id).run();
    return json({ ok: true });
  }

  if (pathname === '/api/printer' && method === 'GET') {
    const row = await env.DB.prepare("SELECT ip, token, serial FROM printer_config WHERE id = 'default' LIMIT 1").first();
    return json({ ip: row?.ip || '', token: row?.token || '', serial: row?.serial || '' });
  }

  if (pathname === '/api/printer' && method === 'PUT') {
    const body = await readBody(request);
    if (!body) return json({ error: 'Invalid JSON body' }, 400);
    const ip = String(body.ip || '').trim();
    const token = String(body.token || '').trim();
    const serial = String(body.serial || '').trim();

    await env.DB.prepare(
      "INSERT INTO printer_config (id, ip, token, serial, updated_at) VALUES ('default', ?, ?, ?, datetime('now')) ON CONFLICT(id) DO UPDATE SET ip=excluded.ip, token=excluded.token, serial=excluded.serial, updated_at=datetime('now')"
    ).bind(ip, token, serial).run();

    return json({ ok: true });
  }

  if (pathname === '/api/printer-status' && method === 'GET') {
    const row = await env.DB.prepare("SELECT * FROM printer_status WHERE id = 'default' LIMIT 1").first();
    if (!row) {
      return json({
        id: 'default',
        state: 'offline',
        nozzleTemp: 0,
        nozzleTarget: 0,
        bedTemp: 0,
        bedTarget: 0,
        chamberTemp: 0,
        progress: 0,
        remainingMinutes: 0,
        currentFile: '',
        currentLayer: 0,
        totalLayers: 0,
        fanSpeed: 0,
        errors: [],
        ams: {},
        updatedAt: null,
      });
    }

    return json({
      id: row.id,
      state: row.state || 'offline',
      nozzleTemp: Number(row.nozzle_temp || 0),
      nozzleTarget: Number(row.nozzle_target || 0),
      bedTemp: Number(row.bed_temp || 0),
      bedTarget: Number(row.bed_target || 0),
      chamberTemp: Number(row.chamber_temp || 0),
      progress: Number(row.progress || 0),
      remainingMinutes: Number(row.remaining_minutes || 0),
      currentFile: row.current_file || '',
      currentLayer: Number(row.current_layer || 0),
      totalLayers: Number(row.total_layers || 0),
      fanSpeed: Number(row.fan_speed || 0),
      errors: (() => {
        try { return JSON.parse(row.errors || '[]'); }
        catch { return []; }
      })(),
      ams: (() => {
        try { return JSON.parse(row.ams_data || '{}'); }
        catch { return {}; }
      })(),
      updatedAt: row.updated_at || null,
    });
  }

  if (pathname === '/api/printer-status' && method === 'PUT') {
    const body = await readBody(request);
    if (!body) return json({ error: 'Invalid JSON body' }, 400);

    const toNum = (v, d = 0) => {
      const n = Number(v);
      return Number.isFinite(n) ? n : d;
    };

    await env.DB.prepare(
      "INSERT INTO printer_status (id, state, nozzle_temp, nozzle_target, bed_temp, bed_target, chamber_temp, progress, remaining_minutes, current_file, current_layer, total_layers, fan_speed, errors, ams_data, updated_at) VALUES ('default', ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now')) ON CONFLICT(id) DO UPDATE SET state=excluded.state, nozzle_temp=excluded.nozzle_temp, nozzle_target=excluded.nozzle_target, bed_temp=excluded.bed_temp, bed_target=excluded.bed_target, chamber_temp=excluded.chamber_temp, progress=excluded.progress, remaining_minutes=excluded.remaining_minutes, current_file=excluded.current_file, current_layer=excluded.current_layer, total_layers=excluded.total_layers, fan_speed=excluded.fan_speed, errors=excluded.errors, ams_data=excluded.ams_data, updated_at=datetime('now')"
    ).bind(
      String(body.state || 'offline').toLowerCase(),
      toNum(body.nozzleTemp ?? body.nozzle_temp),
      toNum(body.nozzleTarget ?? body.nozzle_target),
      toNum(body.bedTemp ?? body.bed_temp),
      toNum(body.bedTarget ?? body.bed_target),
      toNum(body.chamberTemp ?? body.chamber_temp),
      Math.round(toNum(body.progress)),
      Math.round(toNum(body.remainingMinutes ?? body.remaining_minutes)),
      String(body.currentFile ?? body.current_file ?? ''),
      Math.round(toNum(body.currentLayer ?? body.current_layer)),
      Math.round(toNum(body.totalLayers ?? body.total_layers)),
      Math.round(toNum(body.fanSpeed ?? body.fan_speed)),
      JSON.stringify(Array.isArray(body.errors) ? body.errors : []),
      JSON.stringify(body.ams || {})
    ).run();

    return json({ ok: true });
  }

  if (pathname === '/api/export' && method === 'GET') {
    const [spools, locations, printer] = await Promise.all([
      env.DB.prepare('SELECT * FROM spools ORDER BY datetime(created_at) DESC').all(),
      env.DB.prepare('SELECT * FROM storage_locations ORDER BY name COLLATE NOCASE ASC').all(),
      env.DB.prepare("SELECT ip, token FROM printer_config WHERE id='default' LIMIT 1").first(),
    ]);

    return json({
      exportedAt: new Date().toISOString(),
      spools: (spools.results || []).map(spoolToApi),
      locations: (locations.results || []).map((r) => ({ id: r.id, name: r.name })),
      printer: { ip: printer?.ip || '', token: printer?.token || '' },
    });
  }

  if (pathname === '/api/import' && method === 'POST') {
    const body = await readBody(request);
    const incoming = Array.isArray(body) ? body : body?.spools;
    if (!Array.isArray(incoming)) return json({ error: 'Invalid import format' }, 400);

    await env.DB.prepare('DELETE FROM spools').run();

    for (const raw of incoming) {
      const spool = toSpoolRow(raw);
      if (!spool.brand || !spool.color_name || Number.isNaN(spool.total_weight) || Number.isNaN(spool.remaining_weight)) continue;
      await env.DB.prepare(
        'INSERT INTO spools (id, brand, color_name, color_hex, material, diameter, total_weight, remaining_weight, location, purchase_date, cost, notes) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
      ).bind(
        spool.id, spool.brand, spool.color_name, spool.color_hex, spool.material, spool.diameter,
        spool.total_weight, spool.remaining_weight, spool.location, spool.purchase_date, spool.cost, spool.notes
      ).run();
    }

    return json({ ok: true });
  }

  return null;
}

export default {
  async fetch(request, env) {
    const url = new URL(request.url);

    if (url.pathname.startsWith('/api/')) {
      const apiResponse = await handleApi(request, env, url);
      if (apiResponse) return apiResponse;
      return json({ error: 'Not found' }, 404);
    }

    if (url.pathname === '/' || url.pathname === '/index.html') {
      return new Response(HTML_CONTENT, { headers: { 'Content-Type': 'text/html;charset=UTF-8' } });
    }
    if (url.pathname === '/app.js') {
      return new Response(JS_CONTENT, { headers: { 'Content-Type': 'application/javascript;charset=UTF-8' } });
    }
    if (url.pathname === '/styles.css') {
      return new Response(CSS_CONTENT, { headers: { 'Content-Type': 'text/css;charset=UTF-8' } });
    }

    return new Response('Not Found', { status: 404 });
  },
};
`;

fs.writeFileSync(path.join(__dirname, 'src', 'index.js'), workerContent);
console.log('Build complete! Generated src/index.js');
